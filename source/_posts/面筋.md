---
title: 面筋
password: 1224
date: 2021-12-20 10:21:12
categories:
tags:
- 面试
---

###### 做接口自动化和UI自动化的流程

接口自动化的流程
1、获取接口文档，分析接口需求和业务逻辑，重点关注请求方法，请求url，请求参数，请求头，请求体，响应
2、设计接口测试用例，评审
3、编写接口自动化测试脚本，调试
4、校验响应数据，分析结果，输出报告
5、后期可结合Jenkins做持续集成

UI自动化的流程
1、评估当前项目是否适合开展UI自动化测试
2、评估项目哪些功能适合开展UI自动化测试
3、确定UI自动化测试框架，测试工具
4、确定做UI自动化的测试资源
5、根据适合做UI自动化的功能模块，根据其功能测试用例筛选可以转化为自动化测试用例的用例集，然后进行评审
6、搭建自动化测试框架
7、编写自动化测试脚本，调试
8、执行脚本，输出测试结果
9、后期可结合Jenkins做持续集成

###### postman 和Charles都用来干嘛
postman 用来做接口调试，也可以做接口自动化测试
Charles：抓包工具，主要是抓取接口，查看请求头，请求体，响应体，进一步分析问题是前端还是后端，也能用来改包，将请求数据改成特定值测试特定场景

###### tcp三次握手，四次挥手

###### 浏览器输入地址，回车，到返回内容，这个过程发生了什么
1、向DNS服务器请求解析URL所对应的IP地址
2、根据IP地址和默认端口建立TCP连接(三次握手)
3、浏览器发出HTTP请求
4、服务器对请求作出响应
5、释放TCP连接(四次挥手)
6、浏览器将该HTML文本显示内容(渲染页面)

###### get、post区别
1.GET请求能够被缓存
2.GET请求会保存在浏览器的浏览记录中
3.以GET请求的URL能够保存为浏览器书签
4.get传送的数据量较小，不能大于2KB。
5.GET请求主要用以获取数据

1.POST请求不能被缓存下来
2.POST请求不会保存在浏览器浏览记录中
3.以POST请求的URL无法保存为浏览器书签
4.post传送的数据量较大，一般被默认为不受限制
###### Redis 常见会出现问题的场景
缓存穿透
缓存击穿
缓存雪崩

###### 模糊查询的语句
like: %代表任意，_代表任意单个字符，[]范围内取一个字符
regexp：正则表达式

###### 什么是索引
索引:为了提高数据查询的效率
保证行的唯一性
有效缩短数据的检索时间
加快表之间的连接
用来排序或分组的字段添加索引可以加快分组或排序

###### 索引的坏处
创建索引和维护索引需要时间成本，成本随数据量增加尔增大
创建索引和维护索引需要空间成本，每一条索引都要占据数据库的物理存储空间，数据量越大，占用空间也越大
加快了查询效率，但降低了增删改效率，因为每次增删改都要动态维护索引，降低了数据的维护速度

###### 什么场景下会用到索引
匹配全值，对索引所在列指定具体值
匹配值的范围查找，索引值能够进行范围查找
仅对索引查询，当查询的列都在索引字段中，查询效率会更高

###### 索引在什么场景下会失效
以%开头的like查询不能利用B-tree索引
数据类型出现隐式转换的时候不会使用索引
如Mysql认为使用索引比全表扫描更慢，则不会使用索引
用or分割的条件，若or前的条件有索引，但or后的条件没有索引，则不会使用索引

###### 索引的类型
唯一索引
主键索引
聚集索引

###### 索引的实现方式
B+tree

###### 查看端口有没有被占用的命令
netstat  -anp  |grep 端口号

###### 进程、线程的区别
![线程、进程区别](\source\_posts\面筋/线程、进程区别.png)

###### 编辑文本、查询日志的命令
vi
cat
tail -f 文件 ：实时查看
###### jvm的组成
PC寄存器
java虚拟机栈
本地方法栈
java堆
方法区

###### BeanShell是干嘛的
主要是接口数据加解密，会添加加解密方法
跨线程组传参时，也可以用他完成

###### jmeter用过什么函数
Random 生成随机函数
V拼接字符串
time返回当前时间
split拆分字符串
if
counter计数器

###### python，1-100求和，一行代码
```
sum(range(1,101))
```

###### python有哪些数据类型
整型
列表
元组
字典
字符串
集合
布尔

###### 哪些是可变对象
可变对象：列表、字典、集合
不可变对象：整型、字符串、元组

###### 个位十位百位千位都有1的数，怎么筛选
```
for i in range(1,101):
    if str(i).find("1") == 0:
        print(i)
```
###### 假设有一个很有桃战性的任务给到你，你之前没有接触过的，你会怎么处理？
•首先，要挖掘这个任务的背景、需求、优先级、完成目标，详细了解这个任务的来龙去脉【挖掘需求】
•然后要了解任务的一个整体架构，比如不同端用到的技术都有哪些，如果看不懂就要跟开发或者负责人沟通清楚【了解架构】
•将任务根据类型或者步骤分成多个小任务，给每个小任务制定详细的测试方案、技术方案【任务分解】
•根据方案查漏补缺自己的知识点和技术，不懂的就积极问【查漏补缺】
•执行任务过程遇到问题记录下来，自行找解决方案或者找开发、大牛解答【沟通疑问】
•最终输出任务结果的时候，输出每个小任务的关键结果数据以及结论【总结结果】

###### 工作中经常有人找你打断你手头上的工作的话你会怎么处理？
一般会有以下四种因素打断手头上的工作
•来自同事、部门的：临时需要你帮忙、临时插入了其他的需求
来自领导的：临时分配你一个不相关的任务
• 来自生活的：朋友、快递等等
• 来自自己的：微博、短信，微信等等
对于前三种属于客观因素，不可抗力只能选择应对，对于第四种屋于主动因素，可以自己提高自制力
•将一些杂事分为两个维度，紧急和不紧急
•将所有紧急的事情连在一起处理，及时给到同事、部门一个答复
•对于不紧急的事情，先给同事、部门一个预期解决事情时间点的答复，后面再进行处理
另外，自己每天的工作都要有一个详细的时间表

###### Python 有用过哪些库？
标准库：
•os： 提供多种操作系统功能接口的模块
•sys：提供Python运行环境的变量，函数的模块
•random：随机数
•math：数学
•datetime：基本的三期、时间类型
•time：时间的访问 转换
•pprint：美观打印
•hashlib：哈希库
•pathlib：文件系統路径库
•logging：日志工具
•json：JSON 解码、编码
•re：正则表达式
第三方库：
•requests:HTTP 请求
•pandas：分析结构化数据的库，比如excel
•numpy：数学计算库
•pytest：单元测试框架库
•allure：测试报告库
•selenium：ui 自动化测试库
•appium：APP 自动化测试库

###### 等待有哪些？
强制等待：timesleep() 不推荐使用，属于硬编码
隐式等待：implicitly_wait，全局生效，作用于整个 webDriver 生命周期，用于页面等待
显式等待：WebDriverWait，局部生效，作用于某个元素，使用显式等待可以提高执行速康和健壮性

###### 有几种元素定位表达式
1、id
2、class
3、name
4、标签
5、css选择器
6、xpath选择器
7、超链接文本(精确匹配)
8、超链接文本(模糊匹配)

###### 怎么选择定位表达式
•如果元素有id会优先用id选择器
•如果没有id，但有name属性，就会选择name选择器
•其他情况一般都会用css选择器，因为对css比较熟悉
• 而且html本身就与css配合使用，它实现的原理是匹配对象，而xpath是配合xml工作的，实现的原理是遍历
•如果css选择器定位失败，会尝试xpath选择器，因为它也是万能选择器

###### 你能仔细说说你怎么做的自动化项目吗？
如果是 UI 自动化测过项目的话，我是用了 Selenium + Pytest + allure
•然后结合了 PO 模式，PageObject 页面对象模式，将整个项目分了三层
•对象库层，主要是对selenium 的一些方法进行二次封装，提高复用性和健壮佳
•页面操作层，封装页面的元素对条和元素操作方法
•测试用例层，使用 pytest 编写测试用例
如果是接口自动化测试项目的话：
•postman
•jmeter + Ant + Jenkins
•Python Requests库 + Pytest + Allure + Docker + Jenkins + Gitab

###### 你做的项目中有碰到什么困难吗？能具体说说吗，描述清楚什么问题，问题的原因，怎么解决？
•做UI自动化测试的时候就有碰到两个比较辣手的司题，一个是脚本稳定性不好，一个是脚本执行速康较慢的
•做UI自动化测试最关键的因素是稳定性，如果稳定性差，那么后期的維护成本将会很高，投入产出比就会低
•自己测试项目的稳定性，比如一喜代码重复跑10次，可能其中一两次会出现偶发性的失败，就是定位元素失败
•执行速度的问题：用例多了之后执行会很慢

###### 解决脚本稳定性问题
环境方面
•配置独立的测试网络，排除网络因素千扰执行速度
•配置单独的测试环境，避免人为干扰，保证项目可靠性、稳定性
项目方面
•减少用例依赖性，即用例间的耦合性要低，不同用例可以独立运行，无序运行
•失败重新运行机制，当测试用例执行失败时自动重新运行，可以通过pytest 的 pytest-repeat 插件完成
•失败截图机制，当测试用例执行失败时自动截图，方便后续查看
•使用显式等待+expect_condition 条件判断类的方法来二次封装 Selenium 的原生方法，比如操作某个元素前
需要先判断元素是否可见，是否能正常操作，提高方法复用性同时也提高了健壮性
•给二次封装的方法添加异常捕捉机制，比如捕提到NoSuchElementException 等常见异常，会刷新页面或者
换个方式定位元素再进行操作，提高方法的健壮性
###### 解夬脚本执行速度问题
环境方面
•配置独立的测试网络，排除网络因素干扰执行速度
•配置单独的测试环境，避免人为干抗，保证项目可靠佳，稳定性
•搭配更好的硬件配置
项目方面
•便用显式等待代替强制等待，隐式等待
•使用 css 选择器代替 xpath 选择器
•使用分布式运行，项目中，我就用了 pytest 的插件 pytest-dist 来分布式运行项目

###### pytest 运行时发生两次错误即停止运行，用什么命令
pytest --maxfail = 2
pytest -x 是用例运行失败则立即停止执行

###### python 怎么把字典转成json字符串
json.dumps()

###### Mysql查询第10-20条数据的命令
limit 9,10

###### 工作中，在应用上发现了一个 Bug，你会怎么定位这个 Bug?
•首先会通过 F12 或者抓包工具看 HTTP 请求是否发送成功和完整
•然后会看看 HTTP 请求的请求头、请求体有没有问题，如果有向题一般就是客户端传参有问题
•如果响应体没有符合预期结果的话，一般就是服务端的问题
•那假设请求，响应都没问题，但容户端展示出来的有问题，则是客户端的向题

###### 三种抓包工具，你举一个工具，说下你;怎么做请求拦截以及响应拦截？
fiddler，两种方式
•bpu str 给包含str的url设置一个请求断点，只拦截请求，不拦截响应
•bpu 清除请求断点
•bpafter str 给包含str的url设置一个响应断点，只拦截响应，不拦截请求
•bpafter 清除响应断点

工具栏
Rules -> Automatic BreakPoints -> Before Requests、 After Responses

Charles
BreakPoint

###### Session 和 Coolie 的作用是什么？
Session
•数据保存在服务端，一般是通过缓存数据库，比如 redis
•用来保存用户的完整信息，交全性高
Cookie
•数据保存在客户端，浏览器
•减轻服务器的压力，但交全性不高，可能会受到 Cookie 欺骗攻击
•浏览器在下次发送请求时会带上 Cookie 的数据
•服务器通过 Cookie 的数据识别出用户唯一ID，然后再去 Redis 查找是否有该用户的详细信息
总的关系
•用户在客户端登录成功后，会通过 Cookie 保存用户的唯一登录 ID，也叫 token
•用户在客户端再次发送请求时，都会带上 Cookie 的数据，即token
•服务端拿到 cookie 中的token 后，通过redis 查找该 token 是否有对应的用户登录信息
•有的话列返回对应的响应，没有的话则要求用户重新登录

######  常见 http 状态码有哪些？
•200：请求成功
•301：永久重定向
•302：暂时重定向
•404：找不到请求地址
•405：请求方法被禁止
•403：服务器拒绝请求
•401：请求权限不足
•400：请求错误
•500：服务器肉部有错误
•502：服务器作为网关或代理，从上游服务器收到无效响应
•503：服务不可用